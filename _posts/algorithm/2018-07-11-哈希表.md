---
layout:     post
title:      "哈希函数应用 "
date:       2018-07-11 
categories: algorithm
tags: 哈希函数

---



通过hash函数计算Key转换成索引







>浮点型：转成整型，再计算模；字符串：转成整型用数学技巧 ，避免字符串太长，溢出

### 哈希函数应用

1. ##### 服务器负载均衡（做分流）

   相同输入导致相同输出，不同输入，均匀分布

#####    2.大文件去重问题：

​     例如有一个100T的文件，每行是字符串，要将重复的字符串打印出来？

> 将文件存储在分布式系统上。用1000台机器，将每行字符串转成hash值，模1000后将每行字符串分布到对应机器上。因为相同的输入得到的hash值一样，模运算完的值一样，导致相同的字符串在一台机器上。

#####   3.百亿黑名单的设计系统，布隆过滤器 

   经典结构，哈希分流，将数据按hash值分散到1000台机器上。 若允许有失误率，用布隆过滤器

   原理：使用一个数组，每个url经过几个hash函数对应数组位置描黑；所有黑名单的每个URL描黑后，布隆过滤器的位类型数组在相应位置被描黑了； 检查URL的时候：计算K个hash函数对应的位置，所有位置被描黑，则URL在黑名单中，否则认为不在。

有100亿个URL的字符串，设计一种数据结构使得url的查找，存储空间变得极低；使用二进制的位运算，计算字符串的hash值，hash/32等于存在哪个字节中，hash%32在字节中的哪个bit上，标记为黑。在使用是用K个hash函数将bit描黑。查找时如通过K个hash函数计算的bit为黑，表示在之前加入过。

> 具体的参数确定，布隆过滤器 开多大m,bit类型的数组，有多少个bit由 样本量n和失误率p决定
> $$
> (1-e^-\frac{n*k}{m})^k
> $$
>
> $$
> m=\frac{-n*lnp}{(ln2)^2}
> $$
>
> m/8后才是字节，
>
> hash函数的个数:
> $$
> K=ln2*\frac{m}{n}
> $$
> 预期失误率
> $$
> (1-e^-\frac{n*k}{m})^k
> $$



#####     4.一致性哈希

服务器抗压结构，经典结构：后端 服务器集群组，当有个request来请求时，前端有相同的hash函数。经过hash函数mod上服务器个数后，放到对应的服务器上。因为不同的String经过hash函数算完后，**均匀**的分配，所以服务器负载均衡

缺点：当想要加机器时，和hash表扩容一样，要把所以的数据重新计算hash值，然后扔到扩完后的机器上。经典结构，数据迁移全部数据都要迁移，每一条信息都要重新计算hash；

一致性哈希：hash函数的范围想成环，假设有三台机器，每台机器可以用特征（Mac地址，IP）转成hash值，对应环上的一个点。假设：我把“苹果”这条信息存在机器上，“苹果”这个key经过hash函数计算后得到hash值，这个值对应环上的一个位置；顺时针的找离这个位置最近的机器，它负责去存，查时一样。

实现：把机器计算hash值排序成一个数组（放在前端的每台机器上），查找时通过二分查找的方式，找到第一个>=hash值得机器，在加机器时，只用把一段机器上数据迁移到新的机器上。

但由于当机器数量少的时候，不能保证环是均分，负载就不均匀，hash函数的性质，量在多的时候是均分的。在加一个机器时，又不能保证均分。

解决的技术：虚拟节点技术，假设有三台机器，给每台机器分配1000个虚拟结构，准备路由表，物理机器-虚拟节点之间可以相互查找。然后用虚拟节点去分配hash值，虚拟节点解决的域给物理节点处理，分配很均匀

一致性hash可以把数据迁移的代价变的很低，同时又负载均衡。

负载均衡：虚拟节点技术


