---
layout: post
title:  "Java多线程"
date:    2018-04-16 
categories: Java
tags:  Java
---

* content
{:toc}
### **多线程生命周期**

新建，就绪，运行，阻塞，死亡

**新建**：用new和 Thread类创建线程对象，调用Start方法进入就绪状态（runnable）

**就绪**：就绪状态是处于线程就绪队列中，还没分配CPU，

**运行**：运行状态（running）会执行run方法中的程序；运行可以变为三种状态：就绪，阻塞，死亡；
  在失去CPU的情况会变成就绪状态，可调用yield（）方法实现；
  成为阻塞状态：sleep（）方法休眠，阻塞式IO等待资源时，同步监视器，线程等待通知notify，用suspend方法将线程挂起；

**阻塞**：阻塞状态（Blocked）

**死亡**：在线程运行完或强制终止，进入死亡状态；如stop（），destroy（）方法，

> 就绪队列不一定是按先进先出调度的；若在主线程中用Thread.sleep让主线程休眠，可以让子线程立即运行

```Java
#开始线程
public void start();
public void run();

#
public void stop();
public void interrupt();

```

##### 线程死锁

**什么是线程死锁**

指两个或多个线程相互持有对方需要的资源，导致线程处于等待状态，而不能向前推进；

**线程死锁的条件**

互斥：一个资源每次只能一个线程使用

请求和保持：进行因请求资源阻塞时，对已获得的资源不会释放

不可剥夺：进程获得的资源在没使用完前，不能被剥夺

循环等待：多个线程之间相互循环等待资源的关系

> 参考操作系统死锁相关的内容

**如何避免线程死锁：**

破坏产生死锁条件中一个就可以了

互斥：每次使用时拷贝一份

请求和保持：请求的资源没有是，释放自己的资源

不可剥夺：让进程放弃自己的资源

循环等待：给线程指定编号和执行的顺序

**重点：**控制加锁的顺序 解决死锁是最常见的方法

#### 线程安全

多个线程访问临界资源时不安全，有两种办法

线程同步：1. 用Synchronized关键字加上锁机制，

线程间通信：  wait 和notify方法



##### synchronized

​         synchronized修饰的方法或代码块在任意时刻只能有一个线程执行 ，保证了多线程之间访问资源的同步性。

> 早期版本是重量级锁，依靠底层 操作系统实现的，由于线程切换要从用户态转内核态，效率低 。
>
> 优化方法：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等 

使用场景：

给当前对象实例加锁 ，修饰静态方法，给当前类加锁，会作用于类的所有对象实例 ，

双重校验锁实现对象单例（线程安全） 

```Java
public class Singleton{
    private volatile static Singleton uniqueInstance;
    private Singleton(){}
    public static Singleton getUniqueInstance(){
        //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if(uniqueInstance==null){
            //类对象加锁
            synchronized(Singleton.class){
                if(uniqueInstance==null){
                    uniqueInstance=new Singleton();
                }
            }
        }
        return uniqueInstance;
    }

}
```

> 		synchronized(this){
> 			System.out.print("hollo world");
> 		}
> synchronized底层实现原理：同步代码块用的monitorenter、monitorexit；修饰方法用ACC_synchronized标识。
>
> 优化方式：偏向锁，轻量级锁用的CAS操作，自旋锁和自适应锁，**轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉**。
>
> 挂起线程/恢复线程的操作都需要到内核态完成，用户态转换到内核态会耗费时间。而**一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。** 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋**。



##### volatile 

volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序 

volatile是轻量级，性能要好，且只能用于变量，保证多线程之间的**可见性** ，不保证**原子性** ；synchronized可以修饰方法以及代码块 ；而 synchronized解决的是多个线程之间访问资源的同步性。 



#### 线程池 

 有几个线程，在分配任务时会选择线程池中的线程运行程序，

降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，
使用线程池可以进行统一的分配，调优和监控 

##### Runnable和Callable

线程池执行需要实现Runnable，Callable接口，实现类都可以被Thread Pool Executor或ScheduledTreadPoolExecutor；Callable会返回结果。



execute()  不返回值，submit（）返回值

阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 















> 原子性，可见性 ，



- **同步：** 发起一个调用后，调用结果不返回，要自己去。

- **异步：** 发起一个调用后，结果会依靠事件，回调等机制来通知调用者其返回。

  阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回

  **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回

> 烧水时在那里傻等着水开（**同步阻塞**）。在烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（**同步非阻塞**）。
>
> 如果水开了会发出声音，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（**异步非阻塞**）。

##### 1. BIO (Blocking I/O)

1.1传统 BIO

​      BIO 处理多个客户端请求时，为每个客户端创建一个新的线程进行处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 **一请求一应答通信模型** 。

​       例如：我们做的通讯系统，每个客户端连接服务端都会建立一个线程；当并发访问量增加后会导致线程堆栈溢出或不能创建新的进程，最后导致死机。

​        缺点：如果连接不做任何事情，会造成不必要的线程开销；

1.2 伪异步 IO

​         采用线程池和任务队列 实现 伪异步的 I/O  ， 将客户端的请求封装成Task，给线程池进行处理，线程池维护着一个消息队列和N个活跃的进程。活跃进程会对消息队列的任务进行处理。优点是，可以设置线程池的最大线程数和消息队列大小。不会发生资源耗尽宕机的情况。

##### 2.NIO（New I/O）

​     NIO是同步非阻塞I/O模型，JDK1.4引入java.nio包，提供了channel，buffer，selector等方法；读写数据的方式，创建缓冲区，从通道读写数据；

---
Buffer:IO面向流（stream），而NIO面向缓冲区（Buffer）
channel :NIO通过Channel（通道）进行读写，通道是双向的，可读可写，用buffer实现。流是单向的
selector:用于单个线程处理多个通道

缺点:原始NIO的bug太多，代码复杂；


> NIO中的N可以理解为Non-blocking

##### 3.AIO(Asynchronous I/O)

异步非阻塞的IO, 是基于事件和回调机制实现的，

> 应用操作之后会直接返回，不会堵塞; 当后台处理完，os会**通知**相应的**线程**进行后续的操作。
>
> AIO 是异步IO的缩写



Atomic 原子类** 	

Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 

原子类说简单点就是具有原子/原子操作特征的类 

java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic  

基本类型 

AtomicInteger：整形原子类
AtomicLong：长整型原子类 

讲讲 AtomicInteger 的使用 



AtomicInteger 类的原理 :CAS+volatile+native方法




Java 对象的创建过程 

new /反射机制



# 备注：

Linux的基本IO模型

在Java中，主要有三种IO模型，分别是阻塞IO（BIO）、非阻塞IO（NIO）和 异步IO（AIO）；可理解为是Java语言对**操作系统的各种IO模型**的封装

Java中提供的IO有关的API，在文件处理的时候，其实依赖操作系统层面的IO操作实现的。比如在Linux 2.6以后，Java中NIO和AIO都是通过epoll来实现的，而在Windows上，AIO是通过IOCP来实现的。



在Linux(UNIX)操作系统中，共有五种IO模型：**阻塞IO**、**非阻塞IO**、**信号驱动IO、IO复用**以及**异步IO模型**

阻塞IO:

非阻塞IO: 直接返回。然后通过轮询的方式

信号驱动IO: 读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号

IO复用模型:多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中

真正的数据拷贝过程，都是同步进行的。

> 我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。
>
> 烧水的报警器一响，整个烧水过程就完成了。水已经是开水了。 
>
> 钓鱼的报警器一响，只能说明鱼儿已经咬钩了，但是还没有真正的钓上来。
>
> 所以 ，使用带有报警器的水壶烧水，烧水过程是异步的



进程间的通讯方式：管道，信号量，消息队列，共享内存，套接字（socket)

线程间的通信方式：锁机制，信号量，信号



异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。

唯一异步I/O