---
layout: post
title:  "线程"
date:    2018-04-16 
categories: Java
tags:  Java
---

* content
{:toc}
##### **多线程生命周期**

新建，就绪，运行，阻塞，死亡

**新建**：用new和 Thread类创建线程对象，调用Start方法进入就绪状态（runnable）

**就绪**：就绪状态是处于线程就绪队列中，还没分配CPU，

**运行**：运行状态（running）会执行run方法中的程序；运行可以变为三种状态：就绪，阻塞，死亡；
  在失去CPU的情况会变成就绪状态，可调用yield（）方法实现；
  成为阻塞状态：sleep（）方法休眠，阻塞式IO等待资源时，同步监视器，线程等待通知notify，用suspend方法将线程挂起；

**阻塞**：阻塞状态（Blocked）

**死亡**：在线程运行完或强制终止，进入死亡状态；如stop（），destroy（）方法，

> 就绪队列不一定是按先进先出调度的；若在主线程中用Thread.sleep让主线程休眠，可以让子线程立即运行

```Java
#开始线程
public void start();
public void run();

#
public void stop();
public void interrupt();

```

##### 线程死锁

**什么是线程死锁**

指两个或多个线程相互持有对方需要的资源，导致线程处于等待状态，而不能向前推进；

**线程死锁的条件**

互斥：一个资源每次只能一个线程使用

请求和保持：进行因请求资源阻塞时，对已获得的资源不会释放

不可剥夺：进程获得的资源在没使用完前，不能被剥夺

循环等待：多个线程之间相互循环等待资源的关系

> 参考操作系统死锁相关的内容

**如何避免线程死锁：**

破坏产生死锁条件中一个就可以了

互斥：每次使用时拷贝一份

请求和保持：请求的资源没有是，释放自己的资源

不可剥夺：让进程放弃自己的资源

循环等待：给线程指定编号和执行的顺序

**重点：**控制加锁的顺序 解决死锁是最常见的方法

#### 线程安全

多个线程访问临界资源时不安全，有两种办法

线程同步：1. 用Synchronized关键字加上锁机制，

线程间通信：  wait 和notify方法