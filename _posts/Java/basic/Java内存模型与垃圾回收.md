---
layout: post
title:  "Java内存模型与垃圾回收"
date:    2017-12-16 
categories: Java
tags:  Java
---

* content
{:toc}
https://mp.weixin.qq.com/s?src=3&timestamp=1567131697&ver=1&signature=9f4rYV9MBZ2kbADkjAGQaHVrpS8WOUrpbzC12pflTBHZdCOPiuC6lo4*1k5lpYOmxh6I1A69i14Rzc3ZUrUsyRXc0gpwcFuR35ssNeHYLAFb2-uEBsjvfPQTKoO8jDOoJ5nl7xAcj9RRz*S2-uI9X8dtWZLKHGG*tAMEdRjvoCk=

**1、Java内存模型**

栈（虚拟机栈，本地方法栈），堆（新的对象在这建立），方法区，程序计算器

PC register：放执行字节码的地址

vm stack

堆：对象都在这里，垃圾回收也在这，内存分为了新生代和老生代。新生代分一个Eden和2个Survivor，每次使用Eden空间和一个Survivor空间，Minor GC后将存活的对象coying到另一个Survivor中，然后清除刚才的Eden和Survivor空间





## **垃圾对象如何确定**

**引用计数法**

其原理是：给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，当引用失效时，计数器减1，当计数器值为0时表示该对象不再被使用。

需要注意的是：引用计数法很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用引用计数法来管理内存。

###  

### **可达性分析算法**

“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。



## **3、典型的垃圾回收算法**

**1、Mark-Sweep（标记-清除）算法**



这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：

容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

**2、Copying（复制）算法**



为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：

内存缩减到原来的一半。



很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。

**Mark-Compact（标记-整理）算法**



为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是**将存活对象都向一端移动**，然后清理掉端边界以外的内存。具体过程如下图所示：

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。



目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。



而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。