---
layout:     post
title:      "review "
date:       2019-09-11 
categories: Other
tags: Blog
---



面试题

回答问题考虑三个方面： 定义是什么？实现的原理？应用的场景（包括优缺点有哪些）？

#### 1.字节序？

​       数据如果有好几个字节，往内存里存储时候，有两种方式存储顺序。**从低位地址往高位地址**，叫做小端字节序，从高位往低位存储叫大端字节序。不同的CPU厂家使用字节序并不一样，在主机里也叫主机序。

​     网络通信时字节也有顺序叫网络字节序。为保证不同主机的字节顺序是一致的，在发送时要通过TCP/IP转成网络字节序（默认用大端序），这就屏蔽了不同CPU的差异

​     除此之外，字符编码时也有字节序的问题，比如UTF-16、UTF-32它的字节长度为2，4就要考虑是那种字节序。解决办法是在头部加字符表示是大端还是小端

#### 2.怎么实现非阻塞TCP？

#### 3.描述进程控制块PCB，进程控制块中进程的哪些信息？

​        是操作系统里的一种数据结构，用来表示进程状态，作用是是程序成为一个独立运行的基本单位，实现进程并发执行。OS就是通过PCB来控制进程的，存储在系统内存中。

包含的信息：

> 进程 标识符：进程的编号
>
> 处理机状态：处理机中寄存器的内容，比如：处理机中断后，通用寄存器，指令寄存器的内容就要保存到PCB中，下次使用继续调用。
>
> 进程**调度**信息：进程的状态，优先级等，阻塞状态的事件
>
> 进程**控制**信息：程序和数据的地址，同步和通信机制等

**组织方式**

线性表和索引表(链式)

#### 4.http与https的区别？客户端与服务端通过https进行交互的过程?

http超文本传输协议,https超文本传输安全协议,都是应用层,

HTTP:  明文传输,端口是80

HTTPS: https由http进行通信，但利用SSL/TLS来加密数据包,端口是443, 需要到 CA数字证书认证机构申请证书

https工作流程一般如以下方式：

- 1、**TCP 三次同步握手**
- 2、**客户端验证服务器数字证书**
- 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
- 4、SSL 安全加密隧道协商完成
- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。



SQL中的几个基本命令，使用哪个命令可以在数据存在时进行更新数据，数据不存在的话则插入数据；

简单介绍一下单例模式、工厂模式、装饰着模式？

Java中注解是干嘛用的？

#### 注解的作用

- **格式检查：**告诉编译器信息，比如被@Override标记的方法如果不是父类的某个方法，IDE会报错；
- **减少配置：**运行时动态处理，得到注解信息，实现代替配置文件的功能；
- **减少重复工作：**比如第三方框架xUtils，通过注解@ViewInject减少对findViewById的调用，类似的还有（JUnit、ActiveAndroid等）；

> 注解是个接口，自动继承了Annotation

#### 在地址栏里输入一个URL,到这个页面呈现出来,中间会发生什么？

首先会寻找缓存，查看缓存中是否有记录。缓存的查找记录为：浏览器缓存>系统缓存>路由器缓存。

#### DNS解析

如果没有记录就会到ISP的DNS缓存中查看记录；从根服务器域名服务器开始递归搜索最后得到IP地址，

比如DNS协议是基于udp的，主要目的是为了快

获取到ip地址之后，通过TCP三次握手，协商窗口大小等等建立TCP连接，发送HTTP请求了，非https会被重定向到https协议上，一般而言，浏览器会默认请求http协议，所以服务器会首先返回一个301重定向请求让浏览器知道这是一个https协议的站点，请通过https协议来访问。浏览器拿到301请求之后，会首先建立https连接，也就是ssl四次握手。在握手中拿到网站的证书，然后向域名签发机构确定证书的有效性，其他的握手过程主要是为了确定生成密钥所需的参数。握手完成之后再次构造HTTP GET请求，不过这次内容就是加密的了。

证书包括了什么，为什么要有域名签发机构这么个东西，加密算法为什么是非对称加密？





得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应。

返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面。

#### 页面渲染



一般来说，网页内容除了HTML文件之外还有其他的一些资源，如js、css、图片等等。



在浏览器接收到HTML文件之后，一是去解析其中的DOM结构，另外就是马不停蹄的去获取其他的资源，一边渲染页面，一边拉取其他资源，也是通过HTTP协议的。

HTTP是无状态的,保持HTTP状态:Cookie， Session。

Cookie:服务器生成Cookie发送给客户端，由客户端来保存下来,每次发送消息要加上Cookie，

Session :服务器把客户端信息以某种形式记录在服务器上，这就是 Session。在实现上服务端会给客户端发送给 id 值，每次请求要加上 id 值，id 值在保存在 Cookie里,和Cookie实现类似。

Cookie 和 Session 应用场景：

（1）登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。

（2）session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。



1. HashSet和ArrayList的区别？Python和Java的多线程？
2. Fizz Buzz
3. 是合并两个有序链表
1. 白纸手写代码：平面上有很多个点，判断他们是否能被两条直线全部穿过？
2. 白纸手写代码：给定一个精度，要求实现sqrt函数。
3. 编程题也比较常规不难：把I am a Student. 翻转成 Student. a am I
7. 

Java中HashMap和TreeMap的区别？

都是通过key，value键值对来索引的，线程都不安全

不同：TreeMap元素是有顺序的（基于红黑树实现），HashMap无序（也用红黑树实现了）

区别是加了 Synchor 同步锁，

### 数据结构

#### HashMap:

定义：是存储Key-Value键值对的集合，用来通过Key来查找Value的数据结构。

应用：Hash在存储数据时，利用hash函数计算Key对应的索引位置，把key-value放在索引位置。由于HashMap的长度有限，同一索引位置有多个元素的话，会排成链表的形式（拉链法，新节点插在头部）。

原理：线程不安全，多线程访问会是数据出错，可以使用ConcurrentHashMap保证线程安全。

Hash算法：

```
static final int hash(Object key) {
int h;
// key.hashCode()：返回散列值也就是hashcode
// ^ ：按位异或
// >>>:无符号右移，忽略符号位，空位都以0补齐 右移16位做异或运算
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
} 
```

扩容机制：数组满了后，新建一个容量大的数组放小数组（）

> 允许有一个key为null；散列桶（数组和链表）；
> 底层实现上用的：数组+链表+红黑树（链表长度超过8时转成红黑树）；
> 函数put（key，value），getkey（key）返回value；   
> 初始长度16;   按2的幂次方扩展,使得Hash函数得到的结果分布更加均匀；在实现上数组的长度位与运算取模得到的，代码： (n - 1) & hash
> 方法是 ；  为什么会死锁？
>
> HashMap线程不安全，存在丢失数据的情况，扩容复制时形成闭环，死循环；
>
> HashTable安全，但被淘汰了，可用concurrenthashmap

#### ConcurrentHashMap的实现原理

在1.8版本以前，`ConcurrentHashMap`采用分段锁实现，JDK1.8之后取而代之的是采用`Node` + `CAS` + `Synchronized`来保证并发使用的安全，底层采用数组+链表+红黑树的存储结构，和HashMap一样。

> 分段锁: 将数组分成一段一段；每一段数据配一把锁，只让一个线程访问，其他段的数据可以被其他线程访问。 



#### 线程同步

#### ConcurrentHashMap

怎么保证线程安全的？怎么实现高性能读写？

把整个Map分为N个小的Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。根据key.hashCode()来决定把key放到哪个HashTable中

一致性Hash算法解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题

一致性哈希将整个哈希值空间组织成一个虚拟的圆环



**synchronized 关键字** 

做什么的？ 被它修饰的方法在任意时刻只能有一个线程执行 ，保证了多线程访问资源的同步性。

实现：早期版本属于重量级锁，依靠底层操作系统实现的，由于操作系统线程切换要从用户态转内核态，效率低 。改进：从JVM层面做了优化，比如加了 自旋锁，轻量级锁等。

使用场景：

修饰实例方法，给当前对象实例加锁 

修饰静态方法，给当前类加锁，会作用于类的所有对象实例 ，



双重校验锁实现对象单例（线程安全） 

volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序 

说说 synchronized 关键字和 volatile 关键字的区别 

volatile关键字是轻量级实现，所以volatile性能肯定要好 ；volatile只能用于变量，而synchronized可以修饰方法以及代码块 ；volatile保证多线程之间的可见性 ，不保证原子性 ，而 synchronized关键字解决的是多个线程之间访问资源的同步性。 

线程池 

降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，
使用线程池可以进行统一的分配，调优和监控 



**Atomic 原子类** 

Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 

原子类说简单点就是具有原子/原子操作特征的类 

java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic  

基本类型 

AtomicInteger：整形原子类
AtomicLong：长整型原子类 

讲讲 AtomicInteger 的使用 



AtomicInteger 类的原理 